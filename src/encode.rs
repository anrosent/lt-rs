use std::io::prelude::*;
use std::iter::FromIterator;
use std::fs::File;
use std::mem::{transmute, size_of};

use super::sampler::block::{LTBlockSpec, LTBlockSampler};
use super::sampler::params::LTBlockSamplerParams;

#[derive(Debug, Clone, PartialEq)]
pub struct LTBlock {
  filesize: u64,
  blocksize: usize,
  blockseed: u32,
  data: Vec<u8>
}

// TODO: needs testing
fn num_to_bytes(n: u64, nbytes: usize) -> Vec<u8> {
  let mut buf = vec!();
  for shifts in (0..nbytes).rev() {
    buf.push((n >> (8 * shifts)) as u8);
  }
  println!("NTB: {:?}: {:?}", n, buf);
  buf
}

// TODO: needs testing
fn bytes_to_num(bytes: Vec<&u8>) -> u64 {
  let mut res = 0u64;
  for (ix, &byte) in bytes.iter().rev().enumerate() {
    res |= (*byte as u64) << (8 * ix);
  }
  println!("BTN: {:?}: {:?}", bytes, res);
  res
}

impl LTBlock {
  pub fn encode(&self) -> Vec<u8> {

    // Serialize the struct 
    let mut buf = vec!();
    buf.extend_from_slice(num_to_bytes(self.filesize, size_of::<u64>()).as_slice());
    buf.extend_from_slice(num_to_bytes(self.blocksize as u64, size_of::<usize>()).as_slice());
    buf.extend_from_slice(num_to_bytes(self.blockseed as u64, size_of::<u32>()).as_slice());
    buf.extend_from_slice(self.data.as_slice());

    // Set bytes to NETWORK BYTE ORDER
    for byte in buf.iter_mut() {
      *byte = byte.to_be();
    }
    buf
  }

  pub fn decode(mut bytes: Vec<u8>) -> Result<Self, &'static str> {

    // Set from NETWORK to NATIVE byte order
    for byte in bytes.iter_mut() {
      *byte = u8::from_be(*byte);
    }

    let fs_bytes : Vec<&u8> = bytes.iter().take(size_of::<u64>()).collect();
    if fs_bytes.len() != size_of::<u64>() {
      return Err("Error unpacking filesize");
    }
    let filesize = bytes_to_num(fs_bytes);

    let bz_bytes : Vec<&u8> = bytes.iter().skip(size_of::<u64>()).take(size_of::<usize>()).collect();
    if bz_bytes.len() != size_of::<usize>() {
      return Err("Error unpacking blocksize");
    }
    let blocksize = bytes_to_num(bz_bytes) as usize;

    let bs_bytes : Vec<&u8> = bytes.iter().skip(size_of::<u64>() + size_of::<usize>()).take(size_of::<u32>()).collect();
    if bs_bytes.len() != size_of::<u32>() {
      return Err("Error unpacking blockseed");
    }
    let blockseed = bytes_to_num(bs_bytes) as u32;

    let data = bytes.iter().skip(size_of::<u64>() + size_of::<usize>() + size_of::<u32>()).cloned().collect();

    Ok(LTBlock {
      filesize: filesize,
      blocksize: blocksize,
      blockseed: blockseed,
      data: data
    })
  }
}

#[test]
fn test_serialize(){
  let block = LTBlock {
    filesize: 100,
    blocksize: 10,
    blockseed: 123456,
    data: vec!(1,3,5,7,98,6,4,2)
  };
  let encoded = block.encode();
  println!("encoded: {:?}", encoded);
  assert_eq!(block, LTBlock::decode(encoded).unwrap());
}

pub struct LTEncoder {
  sampler: LTBlockSampler,
  filesize: u64,
  blocksize: usize,
  blocks: Box<LTBlockStore>
}

trait LTBlockStore {
  fn get(&self, ix: usize) -> Option<&Vec<u8>>;
}

struct InMemoryBlockStore {
  blocks: Vec<Vec<u8>>
}

impl InMemoryBlockStore {
  pub fn new(blocksize: usize, file: &File) -> Self {
    let bytes: Vec<u8> = file.bytes().map(|byte| byte.unwrap()).collect();
    let mut blocks = vec!();
    for chunk in bytes.chunks(blocksize) {
      let mut block = vec!();
      block.extend_from_slice(chunk);
      if block.len() < blocksize {
        let npad = blocksize - block.len();
        block.extend_from_slice(vec![0u8; npad].as_slice());
        blocks.push(block);

        // We've hit the end of the file
        break;
      } else {
        blocks.push(Vec::from_iter(block));
      }
    }
    return InMemoryBlockStore {
      blocks: blocks
    }
  }
}

impl LTBlockStore for InMemoryBlockStore {
  fn get(&self, ix: usize) -> Option<&Vec<u8>> {
    self.blocks.get(ix)
  }
}

impl LTEncoder {
  pub fn new(params: LTBlockSamplerParams, file: &mut File) -> Self {
    let meta_res = file.metadata();
    match meta_res {
      Err(e) => panic!("{}", e),
      Ok(meta) => {
        let blocksize = (meta.len()/params.k as u64) as usize;
        LTEncoder {
          filesize: meta.len(),
          blocksize: blocksize,
          sampler: LTBlockSampler::new(params),
          blocks: Box::new(InMemoryBlockStore::new(blocksize, file))
        }
      }
    }
  }
}

impl Iterator for LTEncoder {
  type Item = LTBlock;

  fn next(&mut self) -> Option<LTBlock> {
    let block = self.sampler.next();
    let mut data : Vec<u8> = vec![0u8; self.blocksize];
    for block_ix in block.srcblock_ixs.iter() {
      match self.blocks.get(*block_ix as usize) {
        Some(block) => vec_xor(data.as_mut_slice(), block.as_slice()),
        None => panic!("Invalid block index generated by PRNG")
      }
    }
    return Some(LTBlock {
      filesize: self.filesize,
      blocksize: self.blocksize,
      blockseed: block.seed,
      data: data
    })
  }
}

fn vec_xor(v1: &mut [u8], v2: &[u8]) {
  assert_eq!(v1.len(), v2.len());
  for (ix, b) in v2.iter().enumerate() {
    v1[ix] ^= *b;
  }
}

pub fn encode() {
  println!("encoded!");
}
