use std::io::prelude::*;
use std::fs::File;
use std::iter::FromIterator;
use super::sampler::block::{LTBlockSpec, LTBlockSampler, LTBlockSamplerParams};

pub struct LTBlock {
  filesize: u64,
  blocksize: usize,
  blockseed: u64,
  data: Vec<u8>
}

pub struct LTEncoder {
  sampler: LTBlockSampler,
  filesize: u64,
  blocksize: usize,
  blocks: Box<LTBlockStore>
}

trait LTBlockStore {
  fn get(&self, ix: usize) -> Option<&Vec<u8>>;
}

struct InMemoryBlockStore {
  blocks: Vec<Vec<u8>>
}

impl InMemoryBlockStore {
  pub fn new(blocksize: usize, file: &File) -> Self {
    let bytes: Vec<u8> = file.bytes().map(|byte| byte.unwrap()).collect();
    let mut blocks = vec!();
    for chunk in bytes.chunks(blocksize) {
      let mut block = vec!();
      block.extend_from_slice(chunk);
      if block.len() < blocksize {
        let npad = blocksize - block.len();
        block.extend_from_slice(vec![0u8; npad].as_slice());
        blocks.push(block);

        // We've hit the end of the file
        break;
      } else {
        blocks.push(Vec::from_iter(block));
      }
    }
    return InMemoryBlockStore {
      blocks: blocks
    }
  }
}

impl LTBlockStore for InMemoryBlockStore {
  fn get(&self, ix: usize) -> Option<&Vec<u8>> {
    self.blocks.get(ix)
  }
}

impl LTEncoder {
  pub fn new(params: LTBlockSamplerParams, file: &mut File) -> Self {
    let meta_res = file.metadata();
    match meta_res {
      Err(e) => panic!("{}", e),
      Ok(meta) => {
        let blocksize = (meta.len()/params.k as u64) as usize;
        LTEncoder {
          // TODO: do all these vars the right way
          filesize: 0u64,
          blocksize: 0,
          sampler: LTBlockSampler::new(params),
          blocks: Box::new(InMemoryBlockStore::new(blocksize, file))
        }
      }
    }
  }
}

impl Iterator for LTEncoder {
  type Item = LTBlock;

  fn next(&mut self) -> Option<LTBlock> {
    let block = self.sampler.next();
    let mut data : Vec<u8> = vec![0u8; self.blocksize];
    for block_ix in block.srcblock_ixs.iter() {
      match self.blocks.get(*block_ix as usize) {
        Some(block) => vec_xor(data.as_mut_slice(), block.as_slice()),
        None => panic!("Invalid block index generated by PRNG")
      }
    }
    return Some(LTBlock {
      filesize: self.filesize,
      blocksize: self.blocksize,
      blockseed: block.seed,
      data: data
    })
  }
}

fn vec_xor(v1: &mut [u8], v2: &[u8]) {
  assert_eq!(v1.len(), v2.len());
  for (ix, b) in v2.iter().enumerate() {
    v1[ix] ^= *b;
  }
}

pub fn encode() {
  println!("encoded!");
}
